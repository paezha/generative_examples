# hunting for attractors, source https://blog.k2h.se/post/hunting-for-attractors/

```{r setup}
library(tidyverse)
library(future)
library(furrr)
library(cluster)
library(cowplot)

plan(multisession)

# options
knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
options(dplyr.summarise.inform=FALSE)
update_geom_defaults("point", list(size = 0.1, stroke = 0, shape = 16))

# parameters
scale_ink <- scale_color_gradientn(
  colors = c("white","grey60","#036564", "#033649", "#031634")
  ) 

scale_bg <- scale_colour_gradient(low="grey80", high="black")
scale_grey <- scale_colour_gradient(low="grey60", high="black")
scale_white <- scale_colour_gradient(low="grey60", high="white")

color_ink <- "#124270"
color_old <- "#FEFAEE"

```


```{r functions_math}
# define logistic map
logistic <- function(a, xn, yn) {
  xn1 <- a[1]*xn*(1 - xn)
  yn1 <- 0
  
  c(xn1, yn1)
}

# define difference equations for {x, y} coordinates (quadratic map)
quadratic_2d <- function(a, xn, yn) {
  xn1 <- a[1] + a[2]*xn + a[3]*xn*xn + a[ 4]*xn*yn + a[ 5]*yn + a[ 6]*yn*yn
  yn1 <- a[7] + a[8]*xn + a[9]*xn*xn + a[10]*xn*yn + a[11]*yn + a[12]*yn*yn
  
  c(xn1, yn1)
}

# henon phase function from http://www.complexification.net/gallery/machines/henonPhase/
henon_phase <- function(a, xn, yn) {
  xn1 <- xn * cos(a[1]) - (yn - xn^2) * sin(a[1])
  yn1 <- xn * sin(a[1]) + (yn - xn^2) * cos(a[1])
  
  c(xn1, yn1)
}


# iterate quadratic map
iterate <- function(step_fn, a, x0, y0, iterations, ...) {
  x <- rep(x0, iterations)
  y <- rep(y0, iterations)
  
  for(n in 1:(iterations - 1)) {
    xy <- step_fn(a, x[n], y[n])
    x[n+1] <- xy[1]
    y[n+1] <- xy[2]
  }
  
  tibble(x = x, y = y) %>%
    mutate(n = row_number())
}



```

```{r functions_simulation}
# estimate occurrence of a chaotic behaviour
L <- function(step_fn, a, x0, y0, iterations = 1000) {
  # Really, put the point nearby and see what happens
  nearby_distance <- 0.000001
  
  xy <- c(x0, y0)
  xy_near <- xy + c(nearby_distance, 0)
  
  # Collect the log distance ratios as we iterate
  sum_log_distance_ratios <- 0
  
  for (n in 1:iterations) {
    xy <- step_fn(a, xy[1], xy[2])
    xy_near <- step_fn(a, xy_near[1], xy_near[2])
    
    new_distance = sqrt((xy[1] - xy_near[1])^2 + (xy[2] - xy_near[2])^2)
    
    if (new_distance == 0) {
      # The points have converged
      return (-Inf)
    }
    
    if (abs(new_distance) == Inf) {
      # The points have run away
      return (Inf)
    }
    
    # Move near point after xy
    # We put the near point just behind in the direction that they differ
    angle = atan2(xy_near[2] - xy[2], xy_near[1] - xy[1])
    xy_near <- c(xy[1] + nearby_distance * cos(angle),
                 xy[2] + nearby_distance * sin(angle))
    
    
    sum_log_distance_ratios = sum_log_distance_ratios + log2(new_distance / nearby_distance)
    
  }
  
  sum_log_distance_ratios / iterations
}

# estimate the quantile of density distribution per grid cell
density_quantile <- function(data, gridsize=20) {
  data %>%
    group_by(x = ntile(x, gridsize), y = ntile(y, gridsize)) %>%
    summarize(n = n()) %>% nrow()
}

# estimate 2D point density
density_heatmap <- function(data, gridsize=20, bw=1/10) {
  matrix <- with(data, MASS::kde2d(x, y, n=gridsize, h=bw))$z %>% scale(.)
  
  matrix_long <- matrix %>% reshape2::melt() %>%
    set_names(c("x","y","value")) %>% as_tibble()
  
  return(matrix_long)
}


# low resolution simulation of a single parameter set
compute_grid_data <- function(a, iterations, ...) {
  a %>%
    mutate(xy = future_map(a, ~ iterate(quadratic_2d, ., 0, 0, iterations))) %>%
    # Remove those who have grown very large / might run away
    filter(map_lgl(xy, function(d) with(d, all(abs(x) + abs(y) < 1e7)))) %>%
    mutate(xy = map(xy, normalize_xy))
}

# high resolution simulation of a single parameter set
# data is binned by cells with n as the density of points in this cell
compute_print_data <- function(a, iterations, gridsize, ...) {
  data <- iterate(quadratic_2d, a, x0=0, y0=0, iterations) 
  
  data_scaled <- data %>% 
    mutate(range = max(max(x) - min(x), max(y) - min(y))) %>%
    mutate(x = (x - min(x)) / range,
           y = (y - min(y)) / range)
  
  data_density <- data_scaled %>%
    group_by(x = round(x * gridsize) / gridsize,
             y = round(y * gridsize) / gridsize) %>%
    summarize(n = n())
  
  return(data_density)
}

# high resolution simulation of a single parameter set
# each core is used for a different path with the same parameter set
# data is binned by cells with n as the density of points in this cell
compute_parallel_data <- function(a, iterations, gridsize, ...) {
  CPU_cores <- parallel::detectCores()
  
  data <- tibble(thread = 1:CPU_cores) %>%
    mutate(x0 = runif(length(thread), -0.1, 0.1),
           y0 = runif(length(thread), -0.1, 0.1)) %>%
    mutate(xy = future_pmap(
      .,
      function(x0, y0, ...) iterate(quadratic_2d, a, x0, y0, iterations / CPU_cores))
      ) %>%
    unnest(xy) 
  
  data_scaled <- data %>% 
    mutate(range = max(max(x) - min(x), max(y) - min(y))) %>%
    mutate(x = (x - min(x)) / range,
           y = (y - min(y)) / range)
  
  data_density <- data_scaled %>%
    group_by(x = round(x * gridsize) / gridsize,
             y = round(y * gridsize) / gridsize) %>%
    summarize(n = n())
  
  return(data_density)
}


```

```{r functions_plot}
# normalize coordinates for each simulated graph
normalize_xy <- function(df) {
  range <- with(df, max(max(x) - min(x), max(y) - min(y)))
  
  df %>%
    mutate(x = (x - min(x)) / range,
           y = (y - min(y)) / range)
  
}

render_grid <- function(data, output="facet", color="black", size=0.5, alpha=1/10) {
  
  data <- switch(output,
         "single" = data,
         "facet" = unnest(data, xy))
  
  plot <- data %>%
    ggplot(aes(x, y)) +
    geom_point(color = color, size = size, alpha = alpha) +
    coord_equal() + theme_void()
  
  switch(output,
    "single" = return(plot),
    "facet" = return(plot + facet_wrap(~ pattern) + theme_void())
  )

}

render_print <- function(data, scale_color = scale_grey, size=0.3) {
  plot <- data %>%
    ggplot(aes(x, y)) +
    geom_point(aes(alpha = sqrt(n), color = log(n)), size = size) +
    scale_alpha_continuous(range = c(0, 1), limits = c(0, NA)) +
    scale_color + coord_equal() + theme_void() + theme(legend.position = "none")
  
  return(plot)
}

```

```{r map_logistic, eval=FALSE}
logistic_r <- 3.9

data_map <- iterate(step_fn = logistic, a = logistic_r, x0 = 0.01, y0=0, iterations = 100)

plot_logistic <- data_map %>%
  ggplot(aes(n, x)) +
  geom_line(alpha = 0.2) 

# bifurcation plot : x = f(r) in logistic map.
logistic_grid <- tibble(r = seq(0, 4, length = 2000)) %>%
  mutate(xy = map(r, ~ iterate(logistic, ., 0.01, 0, 2000)))

plot_bifurcation <- logistic_grid %>% unnest(xy) %>% 
  # group_by(r, x = round(x * 1000) / 1000) %>%
  # summarize(n = n()) %>% 
  ggplot(aes(x=r, y=x)) +
  geom_point(alpha=0.1) + theme_bw()

ggsave(
  plot_bifurcation,
  file="./R/figures/attractor_logistic_bifurcation.png",
  dpi=300, width = 6, height = 4, scale = 1)

```


```{r map_henon, eval=FALSE}
henon_a <- c(1, 0, -1.4, 0, 0.3, 0, 0, 1, 0, 0, 0, 0)

data_map <- iterate(step_fn = quadratic_2d, a = henon_a, x0 = 0, y0 = 0, iterations = 1E5)

plot_henon <- data_map %>%
  ggplot(aes(x, y)) +
  geom_point(alpha = 0.1) + 
  coord_equal() + theme_void()

# bifurcation plot : x = f(a) in Henon map.
henon_grid <- tibble(p = seq(-1.5, -1, length = 2000)) %>%
  mutate(
    a = map(p, ~ replace(henon_a, 3, .)),
    xy = map(a, ~ iterate(quadratic_2d, ., 0, 0, 2000))
  )

plot_bifurcation <- henon_grid %>% select(-a) %>% unnest(xy) %>% 
  filter(x > -1.5, x < 1.5) %>% 
  ggplot(aes(x = -p, y = x)) +
  geom_point(alpha = 0.1) + theme_bw()

ggsave(
  plot_bifurcation,
  file="./R/figures/attractor_henon_bifurcation.png",
  dpi=300, width = 6, height = 4, scale = 1)

```


```{r phase_henon, eval=FALSE}
# explore both initial conditions and parameterization effects on Henon phase
# phase space plot : xy = f(x0,y0) in Henon phase.
# inspiration from http://paulbourke.net/fractals/henonphase/

henon_ex = c(-10, 1.2, 1.57, 1.9)
henon_seq = seq(-10, -9, length=4)

design_parameter <- tibble(a = henon_ex)

# TODO smarter filter of initial conditions giving similar orbits (distinct permutations ?)
design_phase <- crossing(
  x0 = seq(0, 1, length = 15),
  y0 = seq(0, 1, length = 15)
  ) %>%
  mutate(s = x0 + y0) %>%
  filter(! y0 == s) %>% 
  arrange(s) %>% 
  mutate(condition = seq_along(x0))

design <- crossing(design_parameter, design_phase)

# simulate then resample each output from a set of initial conditions
data_phase <- design %>%
  mutate(
    xy = future_pmap(
      list(a, x0, y0),
      ~ iterate(a= ..1, x0=..2, y0=..3, step_fn = henon_phase, iterations = 1E5)),
    xy_low = future_map(xy, slice_sample, n=3E3)
  ) 

# plot phase space for each parameter value
data_plot <- data_phase %>% 
  filter(map_lgl(xy, function(d) with(d, all(abs(x) + abs(y) < 1e7)))) %>% 
  select(a, condition, x0, y0, xy_low) %>% 
  unnest(xy_low) %>% 
  group_nest(a) %>% 
  mutate(plot = map(data, render_grid, output="single", size=0.2, alpha=1/5))
  
plot_phase <- plot_grid(plotlist = data_plot$plot)

# export
ggsave(
  plot_phase,
  file="./R/figures/attractor_henon_phase_01.png",
  dpi=300, width = 210, height = 210, units = "mm", scale = 1)

```

```{r map_explore, eval=FALSE}
set.seed(1)

# sample parameter space and filter interesting solutions based on Henrik Lindberg method
# L(quadratic_2d, henon_a, 0.01, 0.01)
# L(quadratic_2d, rep(0, 12), 0.01, 0.01)
table_set <- tibble(pattern = 1:1E5) %>%
  mutate(a = map(pattern, ~ round(runif(12, -1.5, 1.5), 2))) %>%
  mutate(L_val = future_map_dbl(a, ~ L(quadratic_2d, ., 0, 0))) %>%
  filter(L_val > 0)

# export
saveRDS(table_set, file="data/attractor_parameter_set.rds", compress="gzip")

# add a metric for filtering of scatterplot density
data_set <- table_set %>%
  compute_grid_data(5000) %>% 
  mutate(density = map_int(xy, density_quantile, gridsize=20))

# plot
plot_set_keep <- data_set %>% filter(density >= 90) %>% render_grid()
plot_set_discard <- data_set %>% filter(density < 90) %>% render_grid()
plot_set_volume <- data_set %>% filter(density >= 200) %>% render_grid()

plot_set_focus <- data_set %>%
  filter(pattern == 38286) %>%
  compute_grid_data(5E5) %>%
  render_grid()

ggsave(
  plot_set_keep + facet_wrap(vars(pattern), ncol=20),
  file="./R/figures/attractor_set_keep.png",
  dpi=200, width = 7, height = 20, scale = 2)

ggsave(
  plot_set_discard + facet_wrap(vars(pattern), ncol=20),
  file="./R/figures/attractor_set_discard.png",
  dpi=200, width = 7, height = 20, scale = 2)

```



```{r cluster_analysis, eval=FALSE}
n_cluster = 25

# load parameter sets
table_set <- read_rds("data/attractor_parameter_set.rds")

data_cluster <- table_set %>%
  compute_grid_data(2000) %>% 
  mutate(
    density = map_int(xy, density_quantile, gridsize=20),
    heatmap = future_map(xy, density_heatmap, gridsize=20, bw=1/10),
    plot = future_map(xy, render_grid, output="single")
    )

# cluster analysis on parameters space 
matrix_input <- data_cluster %>% pull(a, name=pattern) %>% bind_rows() %>% t() 
cluster_input <- pam(matrix_input, k=n_cluster, pamonce = 5)
data_cluster <- data_cluster %>% mutate(cluster_input = cluster_input$cluster)

# cluster analysis on output space : heatmaps based on 2D point density distribution
matrix_output <- data_cluster %>% 
  select(pattern, heatmap) %>% unnest(heatmap) %>%
  pivot_wider(names_from = c(x, y), values_from = value) %>% 
  select(-pattern) %>% as.matrix()

cluster_output <- pam(matrix_output, k = n_cluster, pamonce = 5)
data_cluster <- data_cluster %>% mutate(cluster_output = cluster_output$cluster)

# basic density feature allows to roughly separate dispersed and close-packed graphs
plot_density <- data_cluster %>%
  ggplot(aes(x=density, y=as.factor(pattern))) +
  geom_point() + geom_vline(xintercept = 100) + theme_bw() + 
  theme(axis.text.y = element_blank())

# view clustering result on graph filtered to avoid complex solutions
data_cluster_subset <- data_cluster %>% filter(density < 170) 

# plot heatmaps that represent graphs to cluster  
plot_heatmap <- data_cluster_subset %>% 
  slice_sample(n=49) %>% 
  unnest(heatmap) %>% 
  ggplot(aes(x, y, fill=value)) + 
  geom_raster() + facet_wrap(vars(pattern)) +
  scale_fill_viridis_c()

# similar parameter set do not lead to similar graphs, seems expected...
data_plot_input <- data_cluster_subset %>% 
  group_by(cluster_input) %>% 
  slice_sample(n=20) %>% nest() %>% 
  mutate(plot_list=map(data, ~ plot_grid(plotlist = .x$plot)))

plot_cluster_input <- plot_grid(plotlist = data_plot_input$plot_list, labels=1:n_cluster, scale=0.8)

ggsave(
  plot_cluster_input,
  file="./R/figures/attractor_set_cluster_parameters.png",
  dpi=200, width = 7, height = 10, scale = 2)

# kmeans clustering seems to mainly get graph global shape and orientation
data_plot_output <- data_cluster_subset %>% 
  group_by(cluster_output) %>% 
  slice_sample(n=20) %>% nest() %>% 
  mutate(plot_list=map(data, ~ plot_grid(plotlist = .x$plot)))

plot_cluster_output <- plot_grid(plotlist = data_plot_output$plot_list, labels=1:n_cluster, scale=0.8)

ggsave(
  plot_cluster_output,
  file="./R/figures/attractor_set_cluster_density.png",
  dpi=200, width = 7, height = 10, scale = 2)

```


```{r print_single, eval=FALSE}
table_set <- read_rds("data/attractor_parameter_set.rds")

list_selected_lines_01 <- c(
  75, 2364, 529,
  1820, 2691, 3066,
  3723, 4120, 4668,
  37513, 38286, 92261
)

list_selected_volume_01 <- c(
  683, 1269, 1594, # 976
  2213, 2527, 2670,
  3236, 3339, 4548, 18762, 70138
)

value_pattern <- 38286
footer <- paste(Sys.Date(), value_pattern)

# outputs with orbital-patterns 
plot_print <- table_set %>%
  filter(pattern == value_pattern) %>%
  compute_grid_data(iterations=2E6) %>% unnest(xy) %>% 
  ggplot(aes(x, y)) + 
  geom_point(alpha = 1/50, size = 0.5) +
  coord_equal() + theme_void() 

# outputs without orbital-patterns are better visualized with an estimation of point density
plot_print <- table_set %>%
  filter(pattern == value_pattern) %>%
  compute_print_data(a=.$a[[1]], iterations=3E6, gridsize=3000) %>% 
  ggplot(aes(x, y)) + 
  geom_point(aes(alpha = log(n), color = log(n)), size = 0.4) +
  scale_alpha_continuous(range = c(0, 1), limits = c(0, NA)) +
  scale_colour_gradient(low="grey100", high="black") +
  coord_equal() + theme_void() + theme(legend.position = "none")

# export
ggsave(
  plot_grid(plot_print) +
    draw_label(footer, x=0.99, y=0.01, hjust=1, size=6, color="black"),
  file=glue::glue("./R/figures/attractor_set_{value_pattern}.png"),
  dpi=300, width=295, height=210, scale=1, units="mm")

```


```{r print_shell, eval=FALSE}
table_set <- read_rds("data/attractor_parameter_set.rds")

list_selected_shell <- c(2213)

# series
name <- "shell"

data_print <- table_set %>%
  filter(pattern %in% !! sym(glue::glue("list_selected_{name}"))) %>% 
  mutate(
    data = future_map(a, compute_print_data, iteration=2E6, gridsize=3000),
    plot = map(data, render_print, scale_color=scale_white, size=0.4)
  )

hash_md5 <- digest::digest(data_print)
footer <- paste(Sys.Date(), substr(hash_md5, start = 1, stop = 7))

plot_print <- plot_grid(plotlist = rev(data_print$plot), ncol=1) + 
  draw_label(footer, x=0.99, y=0.01, hjust=1, size=6, color="white") +
  theme(panel.background = element_rect(fill = "black"))

# AX ratio : 6:8.5
ggsave(
  plot_print,
  file=glue::glue("./R/figures/attractor_set_{name}.png"),
  dpi=300, width=210, height=295, scale=1, units="mm")

```

```{r print_evolve, eval=FALSE}
table_set <- read_rds("data/attractor_parameter_set.rds")

list_selected_glyph <- c(8503, 23069)

list_selected_evolve <- c(22646, 21588, 10004, 1017)

# series
name <- "evolve"

data_print <- table_set %>%
  filter(pattern %in% !! sym(glue::glue("list_selected_{name}"))) %>% 
  mutate(
    data = future_map(a, compute_print_data, iteration=3E6, gridsize=3000),
    plot = map(data, render_print, scale_color=scale_bg, size=0.3)
  )

hash_md5 <- digest::digest(data_print)
footer <- paste(Sys.Date(), substr(hash_md5, start = 1, stop = 7))

plot_print <- plot_grid(plotlist = rev(data_print$plot), nrow=1) + 
  draw_label(footer, x=0.99, y=0.01, hjust=1, size=6, color="black") 

# AX ratio : 6:8.5 width=295, height=170
ggsave(
  plot_print,
  file=glue::glue("./R/figures/attractor_set_{name}.png"),
  dpi=300, width=295, height=170, scale=1, units="mm")

```



```{r print_text, eval=FALSE}
table_set <- read_rds("data/attractor_parameter_set.rds")

# plot set of graphs based on density criteria (620/841)
plot_set_characters <- table_set %>%
  compute_grid_data(iterations = 2000) %>% 
  mutate(density = map_int(xy, density_quantile, gridsize=20)) %>% 
  filter(density < 170) %>%
  render_grid(color=color_ink)

ggsave(
  plot_set_characters + facet_wrap(vars(pattern), ncol=20),
  file=glue::glue("./R/figures/attractor_set_characters.png"),
  dpi=300, width=7, height=20, scale=2)

# manually select interesting glyphs
list_selected_characters <- c(
  31, 75, 737, 1556, 2051, 2128, 2669, 2691, 3292, 3603,
  3723, 3788, 4016, 4449, 5797, 13767, 14315, 14603, 15157, 16089, #11813
  16638, 20341, 21548, 21847, 21895, 23384, 24190, 24586, 24939, 24943,
  25319, 25384, 25546, 25990, 25998, 26367, 27606, 29238, 30093, 30647,
  31870, 33263, 33905, 37160, 37461, 37513, 37657, 39385, 39768, 43188, 
  43796, 44876, 45284, 45485, 46358, 46507, 48313, 48534, 48733, 49585
)

plot_set_characters_selected <- table_set %>%
  filter(pattern %in% list_selected_characters) %>% 
  compute_grid_data(iterations = 2000) %>% 
  render_grid(color=color_ink) 

ggsave(
  plot_set_characters_selected + facet_wrap(vars(pattern), ncol=10),
  file=glue::glue("./R/figures/attractor_set_characters_selected.png"),
  dpi=300, width=210, height=295, scale=1, units="mm")

# generate a low resolution sequence list of characters to export
data_characters <- table_set %>%
  filter(pattern %in% list_selected_characters) %>% 
  compute_grid_data(iterations = 1000) %>% 
  mutate(
    plot = map(xy, render_grid, color=color_ink, output="single")
  )

write_rds(data_characters, glue::glue("data/attractor_set_text.rds"), compress="gz")
```


```{r print_example, eval=FALSE}
data_print <- compute_parallel_data(
  a = c(-0.38, -0.60,  0.20, -0.79,  0.10,  0.54,  0.41, -0.59,  0.95, -1.19, -0.65, -0.66),
  iterations = 4E6,
  gridsize = 1000)

plot_print <- data_print %>%
  ggplot(aes(x, y)) +
  geom_point(aes(alpha = sqrt(n), color = log(n)), size = 0, shape = 20) +
  scale_alpha_continuous(range = c(0, 1), limits = c(0, NA)) +
  scale_color_gradientn(colors = lapply(colourlovers::clpalette(292482)$colors, function(c) paste0('#', c))) +
  coord_equal()

ggsave(plot_print, file="./R/figures/attractor_01.png", dpi=300, width=6, height=8.5, scale=1)

data_print <- compute_parallel_data(
  a = c(-0.16, -0.37, -0.27, 0.16, -0.66, -0.74, -1.11, -0.51, 0.59, 0.81, -0.06, -0.44),
  iterations = 2000000,
  gridsize = 1000)

plot_print <- data_print %>%
  ggplot(aes(x, y)) +
    geom_point(aes(alpha = sqrt(n), color = sqrt(n)), size = 0, shape = 20) +
    scale_alpha_continuous(range = c(0, 1), limits = c(0, NA)) +
    scale_color_gradientn(
      colors = rev(lapply(colourlovers::clpalette(131576)$colors, function(c) paste0('#', c)))) +
    coord_equal()

ggsave(plot_print, file="./R/figures/attractor_02.png", dpi=200, width = 4, height = 6, scale = 1)
```






