# Hunting for attractors

This work is a direct reuse of results from Sprott (1993)^1, Bourke [link](http://paulbourke.net/fractals/sprott/) and the R implementation of quadratic map functions from Lindberg [link](https://blog.k2h.se/post/hunting-for-attractors/).
This code sample parameter space, filter aesthetic functions based on different criterias (Lyapunov exponent, summary of point density distribution, correlation) and display them in a grid.

1. Sprott, J. C. (1993). Automatic generation of strange attractors. Computers & Graphics, 17(3), 325-332.

```{r setup}
library(tidyverse)
library(furrr)

# functions
# remotes::install_github("picasa/generate")
library(generate)

# options
plan(multisession)
options(dplyr.summarise.inform=FALSE)
update_geom_defaults("point", list(size = 0.1, stroke = 0, shape = 16))

```


```{r sample, eval=FALSE}

set.seed(1)

n_total <- 5e5

# generate a set of unique 12 letters sequences from a set of 25 letters (25^12 set)
# get parameters corresponding to sampled sequence
table_set <- tibble(pattern = 1:n_total) %>% 
  mutate(name = map(pattern, ~ sample_sequence(set = LETTERS[1:25], length = 12))) %>% 
  distinct(name, .keep_all = TRUE) %>% 
  mutate(p = map(name, ~ get_parameters(string = .))) 

# filter for functions that do not converge into a single point (25/1e4 @ 1000)
table_set <- table_set %>% 
  mutate(L = future_map_dbl(p, ~ L(quadratic_map, ., 0, 0, iterations = 1000))) %>%
  filter(L > 0) %>% unnest(name)

# compute xy data and point density as an aesthetic metric. (28 / 1000 @ 5000)
# filter diverging functions 
table_set <- table_set %>%
  mutate(xy = future_map(p, ~ iterate(quadratic_map, ., 0, 0, iterations = 5000))) %>% 
  filter(map_lgl(xy, ~ with(., all(abs(x) + abs(y) < 1e7)))) %>% 
  mutate(density = map(xy, ~ density_metric(., gridsize = 50))) %>% 
  mutate(r = map_dbl(xy, ~ with(., cor(x,y)))) %>% 
  select(-xy) %>% unnest(density)

# export
saveRDS(table_set, file="data/attractor_parameter_set_discrete.rds", compress="gzip")

```

```{r collection_scatter, eval=FALSE}

# plot 5 cm square plot in A2 format (40 x 60) n = 8*12 = 96, quality=90
# plot 5 cm square plot in A1 format (60 x 80) n = 12*16 = 192

# load results from previously intensive sampling
table_set <- read_rds("data/attractor_parameter_set_discrete.rds")

# filter functions (aesthetic:sampled ~ 0.1 %)
table_collection <- table_set %>%
  filter(between(L, 0.1, 0.4)) %>% 
  filter(d > 0.30) %>% 
  filter(cv < 1.1) %>% 
  filter(abs(r) < 0.8)

# compute quadratic map at high resolution for a random subset of functions
# post-process xy data (filter early iterations, rescaling)
# filter rare functions that diverge/converge for large iterations
p_seed = 3
set.seed(p_seed)

data_collection <- table_collection %>%
  slice_sample(n = 100) %>% 
  mutate(xy = future_map(p, ~ iterate(quadratic_map, ., 0, 0, iterations = 5e5))) %>% 
  filter(map_lgl(xy, ~ with(., all(abs(x) + abs(y) < 1e7)))) %>% 
  filter(map_lgl(xy, ~ density_metric(.) %>% pull(cv) < 2)) %>% 
  mutate(xy = map(xy, ~ normalize_xy(.))) %>% 
  slice_sample(n = 96)

# compute plots for selected functions
data_collection <- data_collection %>%
  mutate(plot = map(xy, ~ render_plot(., size = 0.1))) %>% 
  arrange(name)

# build plot collection
plot_collection <- plot_grid(
  plotlist = data_collection$plot, ncol = 8, scale = 0.7,
  labels = str_to_title(data_collection$name),
  label_x = 0.2, label_y = 0.15, label_size = 7,
  label_fontface = "italic",
  label_fontfamily = "NewCenturySchoolbook") +
  theme(plot.margin = unit(c(1,1,1,1), "cm")) 

file <- sprintf("set_collection_%02d", p_seed)

ggsave(
  plot_collection,
  file = glue::glue("R/figures/attractors/{file}.png"),
  dpi=300, width = 420, height = 594, scale=1, units="mm")

```

```{r plot_scatter, eval=FALSE}
# Render point sets generated by quadratic maps with scatterplots

set.seed(2)

n_plot = 10       # number of parameter combination to sample
n_iter = 1E6     # number of iterations for the quadratic map

# load results from previously intensive sampling step
table_set <- read_rds("data/attractor_parameter_set_discrete.rds")

# filter functions (aesthetic:sampled ~ 0.1 %)
table_collection <- table_set %>%
  filter(between(L, 0.1, 0.4)) %>% 
  filter(d > 0.30) %>% 
  filter(cv < 1.1) %>% 
  filter(abs(r) < 0.8)

# compute quadratic map at high resolution for a random subset of functions
# post-process xy data (filter early iterations, rescaling)
# filter rare functions that diverge/converge for large iterations
data_collection <- table_collection %>%
  slice_sample(n = n_plot) %>% 
  mutate(xy = future_map(p, ~ simulate_quadratic(., iterations = n_iter))) %>% 
  filter(map_lgl(xy, ~ with(., all(abs(x) + abs(y) < 1e7)))) %>% 
  filter(map_lgl(xy, ~ density_metric(.) %>% pull(cv) < 2)) %>% 
  mutate(xy = map(xy, ~ normalize_xy(.)))

# compute plots for selected functions
data_plot <- data_collection %>%
  mutate(
    plot = map(xy, ~ render_plot(., size = 0.1, alpha = 1/3)),
    file = glue::glue("./R/figures/attractors/collection/scatter_{name}.png")
    )

# export plots
data_plot %>% 
  mutate(
    s = walk2(file, plot, ~ ggsave(
      filename = .x, dpi = 300, scale=1, bg = "white",
      plot = .y + geom_point(alpha= 1/3),
      width = 210, height = 210, units="mm"
      ))
  )

```


```{r plot_graph_rng, eval=FALSE}
# Render point sets generated by quadratic maps with relative neighbourhood graphs.

set.seed(1)

n_plot = 5       # number of parameter combination to sample
n_iter = 1E5     # number of iterations for the quadratic map
n_sample = 2500  # number of points to sample before building the RN graph.

# list pre-selected patterns to simulate
value_pattern = c(
  "GWMEASBXSDLY", "XMGMBDILSCFO", "HGUHKHDJQUFN", "VVKLLANMEDGG",
  "BUOSBOVJJLFJ")

# load results from previously intensive sampling step
table_set <- read_rds("data/attractor_parameter_set_discrete.rds")

# filter functions (aesthetic:sampled ~ 0.1 %)
table_collection <- table_set %>%
  filter(between(L, 0.1, 0.4)) %>% 
  filter(d > 0.30) %>% 
  filter(cv < 1.1) %>% 
  filter(abs(r) < 0.8)

# compute quadratic map at medium resolution for a random subset of functions
data_collection <- table_collection %>%
  slice_sample(n = n_plot) %>% 
  bind_rows(tibble(name = value_pattern)) %>% 
  mutate(
    p = map(name, ~ get_parameters(.)),
    xy = future_map(p, ~ simulate_quadratic(., iterations = n_iter)),
    layout = map(xy, ~ slice_sample(., n = n_sample)))

# render plots and export
data_plot <- data_collection %>%
  mutate(
    plot = future_map(layout, ~ render_graph(
        ., graph = "rng", k = NA, aes = "line", width = 0.3, coord = coord_fixed())),
    file = glue::glue("./R/figures/attractors/collection/graph_rn_{name}.png")
    )

data_plot %>% 
  mutate(
    s = walk2(file, plot, ~ ggsave(
      filename = .x, plot = .y , dpi = 300, scale = 1, bg = "white",
      width = 210, height = 210, units="mm"
      ))
  )

```


