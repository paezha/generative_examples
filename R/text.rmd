
# Generative text systems 

```{r setup}
library(tidyverse)
library(cowplot)

knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)

set.seed(1)

scale_ink <- scale_color_gradientn(
  colors = c("white","grey60","#036564", "#033649", "#031634")
  )

scale_grey <- scale_colour_gradient(low="white", high="black")
scale_white <- scale_colour_gradient(low="black", high="white")

color_ink <- "#124270"
color_old <- "#FEFAEE"

```

```{r functions_attractors_text}

# render a single character
render_plot <- function(data, color="black", alpha=0.2, size=0.5) {
  data %>%
    ggplot(aes(x, y)) +
    geom_point(color = color, alpha = alpha, size = size, stroke = 0, shape = 16) +
    coord_equal() + theme_void()
}

# sample and render a sequence of characters in a list
render_sequence <- function(n, length, data) {
  data %>%
    sample(size=n, replace = TRUE) %>% 
    plot_grid(plotlist = ., nrow=length) + 
    theme_void() + theme(plot.margin = unit(c(1,0,1,0), "cm")) 
}

# render a paragraph from an existing text and a set of characters
render_paragraph <- function(text, data, ncol=80, scale=0.9) {
  seq <- text %>% str_to_lower() %>% str_split(., "") 
  # join characters with glyph plots, non-match creates NULL plot (blank space with cowplot)
  data <- tibble(character=seq[[1]]) %>%
    left_join(data %>% select(character, pattern, plot=plot_ld)) 
  # render plots here to allow some variability in final layout ?
  plot_grid(plotlist = data$plot, ncol=ncol, scale=scale)
}
```

```{r plot_attractors_sample, eval=FALSE}
data_characters <- read_rds("data/attractor_set_text.rds")

data_glyphs <- data_characters %>% slice_sample(n = 49) 
plot_glyphs <- plot_grid(plotlist = data_glyphs$plot, scale = 0.6, ncol = 7)

ggsave(
  plot_glyphs,
  file="./R/figures/attractor_set_glyphs.png",
  dpi=300, width=210, height=210, scale=1, units="mm")

```


```{r plot_attractors_random, eval=FALSE}
# pre-generate a fixed set of glyphs and randomly sample sequence

# use glyphs based on 2D ODE (see attractors.rmd)
data_characters <- read_rds("data/attractor_set_text.rds")

# sample different glyphs in different sequence length to emulate text
set.seed(1)

data_print <- tibble(character=sample(20:60, size=9, replace = TRUE)) %>% 
  mutate(sequence = map(character, render_sequence, data=data_characters$plot, length=60))

hash_md5 <- digest::digest("data/attractor_set_text.rds", file=TRUE)
footer <- paste(Sys.Date(), substr(hash_md5, start = 1, stop = 7))

plot_text <- plot_grid(plotlist = data_print$sequence, ncol = nrow(data_print)) + 
  draw_label(footer, x=0.99, y=0.01, hjust=1, size=6, color=color_ink) +
  theme(panel.background = element_rect(fill = "white"))

ggsave(
  plot_text,
  file=glue::glue("./R/figures/attractor_set_text_2.png"),
  dpi=300, width=210, height=295, scale=1, units="mm")

```

```{r plot_attractors_letters, eval=FALSE}
# map glyphs to letters and use existing text to generate glyphs sequence

# use glyphs based on 2D ODE (see attractors.rmd) and add a lower resolution
data_characters <- read_rds("data/attractor_set_text.rds") %>% 
  mutate(
    xy_ld = map(xy, sample_n, size=250),
    plot_ld = map(xy_ld, render_plot)
  )
  
# define a character map
set.seed(1)

chr_dot <- 43188
chr_comma <- 1556

data_glyphs <- data_characters %>% 
  filter(! pattern %in% c(chr_dot, chr_comma)) %>% 
  sample_n(26) %>% 
  bind_rows(data_characters %>% filter(pattern %in% c(chr_dot, chr_comma))) %>%
  mutate(character = c(letters[1:26], ".", ","))

# generate a nonsense text
set.seed(10)
seq_text <- stringi::stri_rand_lipsum(n=3)
seq_prop <- str_length(seq_text)/sum(str_length(seq_text))

data_print <- tibble(text=seq_text) %>% 
  mutate(plot = map(text, render_paragraph, data=data_glyphs, ncol=80, scale=1))

hash_md5 <- digest::digest(data_characters)
footer <- paste(Sys.Date(), substr(hash_md5, start = 1, stop = 7))

plot_text <- plot_grid(plotlist = data_print$plot, ncol=1, rel_heights=c(seq_prop)) +
  draw_label(footer, x=1, y=-0.15, hjust=1, size=6) +
  theme(plot.margin = unit(c(3,1,5,1), "cm")) 

ggsave(
  plot_text,
  file="./R/figures/attractor_set_text_letters.png",
  dpi=300, width=295, height=210, scale=1, units="mm")

```

```{r plot_sars, eval=FALSE}
library(future)
library(furrr)
plan(multisession)

# render SARS-CoV-2 genome sequence

# use glyphs based on 2D ODE (see attractors.rmd) and add a lower resolution
data_characters <- read_rds("data/attractor_set_text.rds") %>% 
  mutate(
    xy_ld = map(xy, sample_n, size=250),
    plot_ld = map(xy_ld, render_plot)
  )

# select one glyph per base
chr_DNA <- c("a"=31, "t"=21847, "g"=3292, "c"=3603)

data_glyphs <- data_characters %>% 
  filter(pattern %in% chr_DNA) %>%
  slice(match(chr_DNA, pattern)) %>% 
  mutate(character = names(chr_DNA))

# get genome sequence
seq_sars <- read_lines("data/SARS-CoV-2.txt", skip=1)

# select 70x70 last characters
data_print <- tibble(text=seq_sars) %>% 
  slice((n()-69):n()) %>% 
  mutate(plot = future_map(text, render_paragraph, data=data_glyphs, ncol=70, scale=1))

title <- paste(sum(str_length(data_print$text))/1000, "kb")
footer <- paste(Sys.Date(), title)

plot_text <- plot_grid(plotlist = data_print$plot, ncol=1) +
  draw_label(footer, x=1, y=0, hjust=1, size=9) +
  theme(plot.margin = unit(c(1,1,1,1), "cm")) 

ggsave(
  plot_text,
  file="./R/figures/attractor_set_text_sars.png",
  dpi=300, width=210, height=210, scale=1.5, units="mm")

```


```{r plot_attractors_compose, eval=FALSE}
# superpose 2 or more simple glyphs by modifying coordinates
# lot of tweaking to get an aesthetic result.
data_characters <- read_rds("data/attractor_set_text.rds") 

plot_text <- data_characters %>% 
  ggplot(aes(x,y)) +
  geom_point(data = . %>% filter(pattern==20341) %>% unnest(xy)) +
  geom_point(data = . %>% filter(pattern==26367) %>% unnest(xy) %>%  mutate(x=x+0.6, y=y+0)) +
  coord_equal() + theme_void()

```


```{r plot_attractors_cluster, eval=FALSE}
# use cluster analysis with a high cluster number to define characters,
# allowing for variability for each character/cluster.

```


```{r functions_graph_text}
library(ggraph)
library(tidygraph)

# generate glyph shapes by using networks
# https://en.wikipedia.org/wiki/Relative_neighborhood_graph


# draw n points in [0-1] in x and y
layout_square <- function(n = 7) {
  data.frame(x=runif(n), y=runif(n)) 
}

# draw n points in a unit circle 
# https://mathworld.wolfram.com/DiskPointPicking.html
layout_circle <- function(n = 7, r = 1, a = -pi/6) {
  r = sqrt(runif(n, 0, r))
  theta = runif(n, 0, 2*pi)
  
  # scale and rotate layout
  layout <- data.frame(
    x0 = r * cos(theta),
    y0 = r * sin(theta)) %>% 
    mutate(x0 = x0 * 0.5) %>% 
    mutate(
      x = x0*cos(a) - y0*sin(a),
      y = x0*sin(a) + y0*cos(a))
    
  return(layout %>% select(x,y))
}

# compute relative neighborhood graph and use points coordinates as graph layout
render_glyph <- function(data, width = 1, strength = 1, type="smooth") {
  
  # graph
  graph <- data %>% cccd::rng() %>% as_tbl_graph()
  
  # plot
  switch(type,
         "smooth" = {
           graph %>%
             ggraph(layout = data) +
             geom_edge_diagonal(
               aes(
                 edge_width = stat(index),
                 alpha = stat(index)),
               lineend = "round", linejoin = "round",
               strength = 1, n = 100) +
             scale_edge_alpha(range = c(0.5, 1), guide="none") +
             scale_edge_width(range = c(1, 2), guide="none")  +
             coord_fixed(
               ratio = 1, expand = TRUE,
               xlim = c(-0.7, 0.7), ylim = c(-0.9, 0.9)) +
             theme_void()
         },
         "line" = {
           graph %>%
             ggraph(layout = data) +
             geom_edge_link(edge_width = width, alpha = 0.5) +
             geom_node_point(size = width * 1.5) +
             coord_fixed() + theme_void()
         },
         stop("Invalid `type` value")
  )
}



# layout_circle(n=5) %>% render_glyph(type="line")

```


```{r plot_graph_constellations, eval=FALSE}
# generate a set of glyphs with a low number of control points
set.seed(1)
n_points = 10

data_glyphs <- tibble(pattern=1:49) %>% 
  mutate(
    layout = map(pattern, ~ layout_square(n = n_points)),
    plot = map(layout, render_glyph, type="line", width=1)
  )

plot_glyphs <- plot_grid(plotlist = data_glyphs$plot, scale = 0.6)

ggsave(
  plot_glyphs,
  file="./R/figures/graph_set_rng_line.png",
  dpi=300, width=210, height=210, scale=1, units="mm")

```

```{r plot_graph_glyphs, eval=FALSE}
# generate a set of glyphs with a low number of control points
set.seed(1)
n_points = 5

data_glyphs <- tibble(pattern=1:49) %>% 
  mutate(
    layout = map(pattern, ~ layout_circle(n = n_points)),
    plot = map(layout, render_glyph, type="smooth", width=1)
  )

plot_glyphs <- plot_grid(plotlist = data_glyphs$plot, scale = 0.6) 

ggsave(
  plot_glyphs,
  file="./R/figures/graph_set_rng_glyphs.png",
  dpi=300, width=210, height=210, scale=1, units="mm")

# glyph variability
# TODO some glyphs are related, use this to get variability for the same glyph. 
# TODO or find main types of control point set and add randomness in a second step
```


```{r plot_spline}

# generate original glyph type by using splines
# https://inconvergent.net/2017/spline-script/
```

