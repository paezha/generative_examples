
# Generative text systems 


```{r setup}
library(tidyverse)
library(cowplot)

#library(future)
#library(furrr)
#plan(multisession)

knitr::opts_chunk$set(echo=FALSE, warning=FALSE, message=FALSE)
# theme_set(theme_void() + theme(legend.position = 'none'))

set.seed(1)

scale_ink <- scale_color_gradientn(
  colors = c("white","grey60","#036564", "#033649", "#031634")
  )

scale_grey <- scale_colour_gradient(low="white", high="black")
scale_white <- scale_colour_gradient(low="black", high="white")

color_ink <- "#124270"
color_old <- "#FEFAEE"

```

```{r text_attractors_functions}

# render a single character
render_plot <- function(data, color="black", alpha=0.1) {
  data %>%
    ggplot(aes(x, y)) +
    geom_point(color = color, size = 0, shape = 20, alpha = alpha) +
    coord_equal() + theme_void()
}

# sample and render a sequence of characters in a list
render_sequence <- function(n, length, data) {
  data %>%
    sample(size=n, replace = TRUE) %>% 
    plot_grid(plotlist = ., nrow=length) + 
    theme_void() + theme(plot.margin = unit(c(1,0,1,0), "cm")) 
}

# render a paragraph from an existing text and a set of characters
render_paragraph <- function(text, data, ncol=80, scale=0.9) {
  seq <- text %>% str_to_lower() %>% str_split(., "") 
  # join characters with glyph plots, non-match creates NULL plot (blank space with cowplot)
  data <- tibble(character=seq[[1]]) %>% left_join(data) 
  # TODO render plots here to allow some variability in final layout ?
  plot_grid(plotlist = data$plot_ld, ncol=ncol, scale=scale)
}
```

```{r text_attractors_random, eval=FALSE}
# pre-generate a fixed set of glyphs and randomly sample sequence

# use glyphs based on 2D ODE (see attractors.rmd)
data_characters <- read_rds("data/attractor_set_text.rds")

# sample different glyphs in different sequence length to emulate text
set.seed(1)

data_print <- tibble(character=sample(20:60, size=9, replace = TRUE)) %>% 
  mutate(sequence = map(character, render_sequence, data=data_characters$plot, length=60))

hash_md5 <- digest::digest("data/attractor_set_text.rds", file=TRUE)
footer <- paste(Sys.Date(), substr(hash_md5, start = 1, stop = 7))

plot_text <- plot_grid(plotlist = data_print$sequence, ncol = nrow(data_print)) + 
  draw_label(footer, x=0.99, y=0.01, hjust=1, size=6, color=color_ink) +
  theme(panel.background = element_rect(fill = "white"))

ggsave(
  plot_text,
  file=glue::glue("./R/figures/attractor_set_text.png"),
  dpi=300, width=210, height=295, scale=1, units="mm")

```

```{r text_attractors_letters, eval=FALSE}
# map glyphs to letters and use existing text to generate glyphs sequence

# use glyphs based on 2D ODE (see attractors.rmd) and add a lower resolution
data_characters <- read_rds("data/attractor_set_text.rds") %>% 
  mutate(
    xy_ld = map(xy, sample_n, size=250),
    plot_ld = map(xy_ld, render_plot, alpha=0.2)
  )
  
# define a character map
set.seed(1)

chr_dot <- 43188
chr_comma <- 1556

data_glyphs <- data_characters %>% 
  filter(! pattern %in% c(chr_dot, chr_comma)) %>% 
  sample_n(26) %>% 
  bind_rows(data_characters %>% filter(pattern %in% c(chr_dot, chr_comma))) %>%
  mutate(character = c(letters[1:26], ".", ","))

# generate a nonsense text
set.seed(10)
seq_text <- stringi::stri_rand_lipsum(n=3)
seq_prop <- str_length(seq_text)/sum(str_length(seq_text))

data_print <- tibble(text=seq_text) %>% 
  mutate(plot = map(text, render_paragraph, data=data_glyphs, ncol=80, scale=1))

hash_md5 <- digest::digest(data_characters)
footer <- paste(Sys.Date(), substr(hash_md5, start = 1, stop = 7))

plot_text <- plot_grid(plotlist = data_print$plot, ncol=1, rel_heights=c(seq_prop)) +
  draw_label(footer, x=1, y=-0.15, hjust=1, size=9) +
  theme(plot.margin = unit(c(3,1,5,1), "cm")) 

ggsave(
  plot_text,
  file="./R/figures/attractor_set_text_letters.png",
  dpi=300, width=295, height=210, scale=1.5, units="mm")

# TODO: test patchwork package for layout *design option*
```

```{r debug_patchwork}
# patchwork
library(patchwork)

p1 <- wrap_plots(data_print_p1 %>% pull(plot_ld) %>% compact(), ncol=80)
p2 <- wrap_plots(data_print_p2 %>% pull(plot_ld) %>% compact(), ncol=80)

plot_text <- p1 + p2 + plot_layout(ncol = 1)

ggsave(plot_text, file="./R/figures/tmp.png", dpi=300, width=295, height=210, scale=1, units="mm")


# TODO test patchwork with list-columns
library(patchwork)
library(tidyverse)

theme_set(theme_void() + theme(legend.position = 'none'))

d <- mtcars %>% 
  group_by(cyl) %>% 
  nest() %>% 
  mutate(plot = map(data, ~ ggplot(., aes(mpg, disp)) + geom_point()))

wrap_plots(d$plot)

# using theme_set caused an error
library(ggplot2)
library(patchwork)

theme_set(theme_void())

p1 <- ggplot(mtcars) + geom_point(aes(mpg, disp)) 
p2 <- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear)) 

p1 + p2

sessionInfo()

# setting the theme at the plot level worked
library(ggplot2)
library(patchwork)

p1 <- ggplot(mtcars) + geom_point(aes(mpg, disp)) + theme_void()
p2 <- ggplot(mtcars) + geom_boxplot(aes(gear, disp, group = gear)) + theme_void()

p1 + p2


reprex::reprex()



```


```{r text_attractors_cluster, eval=FALSE}
# use cluster analysis with a high cluster number to define characters, allowing for variability for each character/cluster.

```


```{r text_graph}
library(ggraph)
library(tidygraph)

# https://en.wikipedia.org/wiki/Relative_neighborhood_graph

graph <- as_tbl_graph(highschool) %>% 
    mutate(Popularity = centrality_degree(mode = 'in'))

# plot using ggraph
ggraph(graph, layout = 'kk') + 
    geom_edge_fan(aes(alpha = stat(index)), show.legend = FALSE) + 
    geom_node_point(aes(size = Popularity)) + 
    facet_edges(~year) 
```


```{r text_spline}
# https://inconvergent.net/2017/spline-script/
```

